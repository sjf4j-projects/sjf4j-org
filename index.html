<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SJF4J ‚Äî Simple JSON Facade for Java</title>
  <meta name="description" content="SJF4J is a simple facade over multiple JSON libraries, providing a unified semantic layer for structured data processing. Supports JSON, YAML, Properties, and an in-memory Object-Based Node Tree.">
  <meta name="keywords" content="SJF4J, Java, JSON, JSON library, JsonObject, JsonPath, JOJO, JSON Schema, JSON Patch, facade">
  <meta property="og:title" content="SJF4J ‚Äî Simple JSON Facade for Java">
  <meta property="og:description" content="Enjoying JSON-oriented Java development. A simple facade over multiple JSON libraries with a unified semantic layer.">
  <meta property="og:url" content="https://sjf4j.org">
  <meta property="og:type" content="website">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%230d1117'/><text x='16' y='22' text-anchor='middle' font-family='monospace' font-size='16' font-weight='bold' fill='%2358a6ff'>&#x7B;&#x7D;</text></svg>">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- Prism.js ‚Äî Tomorrow Night theme -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

  <!-- Site CSS -->
  <link rel="stylesheet" href="css/style.css">
</head>
<body>

<!-- ===================== MOBILE HEADER ===================== -->
<header class="mobile-header">
  <span class="logo-text">SJF4J</span>
  <button class="hamburger" id="hamburger" aria-label="Toggle navigation">‚ò∞</button>
</header>

<!-- ===================== OVERLAY ===================== -->
<div class="sidebar-overlay" id="sidebar-overlay"></div>

<!-- ===================== LAYOUT ===================== -->
<div class="layout">

  <!-- ================== SIDEBAR ================== -->
  <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
    <div class="sidebar-logo">
      <a href="#hero">
        <svg class="logo-icon" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <rect width="32" height="32" rx="6" fill="#161b22"/>
          <text x="16" y="22" text-anchor="middle" font-family="monospace" font-size="16" font-weight="bold" fill="#58a6ff">{}</text>
        </svg>
        <span>SJF4J</span>
      </a>
    </div>
    <div class="sidebar-nav">
      <div class="nav-section">Documentation</div>
      <a href="#overview">Overview</a>
      <a href="#obnt">Object-Based Node Tree</a>
      <a href="#getting-started">Getting Started</a>
      <a href="#jsonobject">JsonObject</a>
      <a href="#jsonpath">JsonPath</a>
      <a href="#nodestream">NodeStream</a>
      <a href="#jojo">JOJO ‚Äî Domain Modeling</a>
      <a href="#sjf4j-api">Data Conversion (Sjf4j)</a>
      <a href="#jsonpatch">JsonPatch</a>
      <a href="#jsonschema">JsonSchema</a>
      <a href="#benchmark">Benchmark</a>
      <a href="#contributing">Contributing</a>
    </div>
  </nav>

  <!-- ================== MAIN ================== -->
  <main class="main">

    <!-- ============ HERO ============ -->
    <section id="hero" class="hero">
      <div class="hero-inner">
        <h1>SJF4J ‚Äî <span>Simple JSON Facade</span> for Java</h1>
        <p class="tagline">Enjoying JSON‚Äëoriented Java development</p>

        <div class="badges">
          <a href="https://github.com/sjf4j-projects/sjf4j/actions" target="_blank" rel="noopener">
            <img src="https://img.shields.io/github/actions/workflow/status/sjf4j-projects/sjf4j/gradle.yml?branch=main" alt="Build">
          </a>
          <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener">
            <img src="https://img.shields.io/github/license/sjf4j-projects/sjf4j" alt="License">
          </a>
          <a href="https://central.sonatype.com/artifact/org.sjf4j/sjf4j" target="_blank" rel="noopener">
            <img src="https://img.shields.io/maven-central/v/org.sjf4j/sjf4j" alt="Maven Central">
          </a>
          <a href="https://github.com/sjf4j-projects/sjf4j" target="_blank" rel="noopener">
            <img src="https://img.shields.io/github/stars/sjf4j-projects/sjf4j?style=social" alt="Stars">
          </a>
          <a href="https://bowtie.report/#/implementations/java-sjf4j" target="_blank" rel="noopener">
            <img src="https://img.shields.io/endpoint?url=https%3A%2F%2Fbowtie.report%2Fbadges%2Fjava-org.sjf4j-sjf4j%2Fsupported_versions.json" alt="Supported Dialects">
          </a>
        </div>

        <div class="hero-install">
          <span class="comment">// Gradle</span><br>
          <span class="keyword">implementation</span>(<span class="string">"org.sjf4j:sjf4j:{version}"</span>)
        </div>

        <div class="cta-buttons">
          <a href="#getting-started" class="btn btn-primary">Get Started</a>
          <a href="https://github.com/sjf4j-projects/sjf4j" target="_blank" rel="noopener" class="btn btn-secondary">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
            GitHub
          </a>
        </div>
      </div>
    </section>

    <!-- ============ CONTENT ============ -->
    <div class="content">

      <!-- ======== OVERVIEW ======== -->
      <section id="overview" class="section">
        <h2><span class="section-icon">üîç</span> Overview</h2>
        <p>
          <strong>SJF4J (Simple JSON Facade for Java)</strong> is a simple facade over multiple JSON libraries,
          providing a unified semantic layer for structured data processing grounded in JSON specifications.
        </p>
        <p>
          Rather than reinventing the wheel, SJF4J sits on top of popular parsers ‚Äî Jackson, Gson, Fastjson2 ‚Äî
          and exposes a consistent, expressive API across all of them. You switch parsers by swapping a dependency;
          your application code stays unchanged.
        </p>
        <p>
          Beyond JSON, SJF4J also supports <strong>YAML</strong> (via SnakeYAML),
          <strong>Java Properties</strong> (built-in), and a unified in-memory
          <strong>Object-Based Node Tree (OBNT)</strong> that lets you work with plain Java objects
          using the same JSON-semantic APIs.
        </p>
        <ul>
          <li><strong>JsonObject / JsonArray</strong> ‚Äî primary entry points with rich APIs</li>
          <li><strong>JsonPath</strong> ‚Äî full RFC 9535 JSON Path and RFC 6901 JSON Pointer support</li>
          <li><strong>NodeStream</strong> ‚Äî declarative, stream-based traversal</li>
          <li><strong>JOJO</strong> ‚Äî hybrid domain models combining typed fields and dynamic JSON access</li>
          <li><strong>JsonPatch</strong> ‚Äî RFC 6902 patch, diff, and merge</li>
          <li><strong>JsonSchema</strong> ‚Äî full JSON Schema Draft 2020-12 compliance</li>
        </ul>
      </section>

      <!-- ======== OBNT ======== -->
      <section id="obnt" class="section">
        <h2><span class="section-icon">üå≥</span> Object-Based Node Tree (OBNT)</h2>
        <p>
          SJF4J maps structured data into an <strong>Object-Based Node Tree (OBNT)</strong> and exposes a
          unified, expressive API for navigation, querying, mutation, and validation.
        </p>
        <p>
          Unlike traditional JSON libraries that rely on dedicated AST node hierarchies,
          <strong>all nodes in SJF4J are represented as native Java objects</strong>:
        </p>

        <div class="mermaid-wrap">
          <div class="mermaid">
graph BT
    node(("&lt;Object&gt;<br/>Object-Based Node Tree"))
    node --> object(("JSON Object<br/>{ }"))
        object --> map("Map")
        object --> jo("JsonObject")
            jo --> jojo("&lt;JOJO&gt;<br/>(extends JsonObject)")
        object --> pojo("&lt;POJO&gt;")
    node --> array(("JSON Array<br/>[ ]"))
        array --> list("List")
        array --> ja("JsonArray")
            ja --> jajo("&lt;JAJO&gt;<br/>(extends JsonArray)")
        array --> arr("Array")
        array --> set("Set")
    node --> value(("JSON Value<br/>..."))
        value --> string("String")
        value --> number("Number")
        value --> boolean("Boolean")
        value --> nodeValue("&lt;NodeValue&gt;")
          </div>
        </div>

        <h3>JSON Object (<code>{}</code>)</h3>
        <ul>
          <li><strong><code>Map</code></strong> ‚Äî A generic key-value representation using standard Java <code>Map</code>.</li>
          <li><strong><code>JsonObject</code></strong> ‚Äî A lightweight wrapper providing JSON-semantic APIs.
              Can also wrap POJO fields via getter/setter access when backed by a subclass.</li>
          <li><strong><code>&lt;POJO&gt;</code></strong> ‚Äî A strongly typed Java object with fields, getters, and setters.</li>
          <li><strong><code>&lt;JOJO&gt;</code></strong> (JSON Object Java Object) ‚Äî A hybrid that extends <code>JsonObject</code>
              while also behaving like a typed Java object, combining dynamic JSON access with POJO safety.</li>
        </ul>

        <h3>JSON Array (<code>[]</code>)</h3>
        <ul>
          <li><strong><code>List</code></strong> ‚Äî A standard Java <code>List</code> as a direct JSON array representation.</li>
          <li><strong><code>JsonArray</code></strong> ‚Äî A structured wrapper providing JSON-semantic APIs.</li>
          <li><strong><code>&lt;Array&gt;</code></strong> ‚Äî A native Java array (e.g. <code>String[]</code>, <code>int[]</code>).</li>
          <li><strong><code>&lt;JAJO&gt;</code></strong> (JSON Array Java Object) ‚Äî Extends <code>JsonArray</code> for domain-specific array models (e.g. <code>JsonPatch</code>).</li>
          <li><strong><code>Set</code></strong> ‚Äî A Java <code>Set</code> mapped to a JSON array, with no ordering guarantees.</li>
        </ul>

        <h3>JSON Value</h3>
        <ul>
          <li><strong><code>String</code></strong> ‚Äî JSON string values.</li>
          <li><strong><code>Number</code></strong> ‚Äî JSON numeric values, including integers and floating-point.</li>
          <li><strong><code>Boolean</code></strong> ‚Äî JSON <code>true</code> or <code>false</code>.</li>
          <li><strong><code>Null</code></strong> ‚Äî JSON <code>null</code> literal.</li>
          <li><strong><code>&lt;@NodeValue&gt;</code></strong> ‚Äî Typed nodes with optional adapters for mapping to Java types (e.g. <code>LocalDate</code>).</li>
        </ul>
      </section>

      <!-- ======== GETTING STARTED ======== -->
      <section id="getting-started" class="section">
        <h2><span class="section-icon">üöÄ</span> Getting Started</h2>

        <h3>Installation</h3>
        <p>SJF4J requires only <strong>JDK 8</strong> and has no external dependencies.</p>

        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-groovy">// Gradle
implementation("org.sjf4j:sjf4j:{version}")</code></pre>
        </div>

        <h3>JSON Parser Auto-detection</h3>
        <p>
          To handle <strong>JSON</strong> data, add <code>Jackson</code>, <code>Gson</code>, or <code>Fastjson2</code>
          to your classpath. The first available parser in this order will be automatically used.
          If none are detected, SJF4J falls back to its own simple (and slower) built-in parser.
        </p>

        <h3>YAML Support</h3>
        <p>To handle <strong>YAML</strong> data, simply include <code>SnakeYAML</code> in your classpath.</p>

        <h3>Properties Support</h3>
        <p>
          To handle <strong>Java Properties</strong>, there is a built-in parser.
          Note that conversion from <code>java.util.Properties</code> is limited by its format restrictions.
        </p>

        <h3>No-Data Scenarios</h3>
        <p>
          SJF4J can also be used <strong>without parsing any external data</strong>.
          It operates directly on in-memory object graphs via the OBNT,
          providing the same JSON-semantic APIs.
        </p>
      </section>

      <!-- ======== JSONOBJECT ======== -->
      <section id="jsonobject" class="section">
        <h2><span class="section-icon">üì¶</span> JsonObject</h2>
        <p>
          <code>JsonObject</code> is the primary entry point for interacting with the Object-Based Node Tree.
          Its APIs are designed to align with JSON semantics ‚Äî for example, <code>hasNonNull()</code> for
          not-null vs <code>containsKey()</code> for missing.
        </p>

        <h3>Basic Access and Mutation Methods</h3>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Class</th><th>Method</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td>JsonObject</td>
                <td><code>getNode(key)</code></td>
                <td>Returns the raw underlying node as an <code>Object</code>, without any type conversion or adaptation.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>get(key, type)</code><br><code>getLong(key)</code>&nbsp;‚Ä¶</td>
                <td><code>getXxx</code> performs <strong>type-safe access</strong> with minimal adaptation when necessary (e.g. <code>Double</code> ‚Üí <code>Float</code>, <code>Integer</code> ‚Üí <code>Long</code>).</td>
              </tr>
              <tr>
                <td></td>
                <td><code>getAs(key, type)</code><br><code>getAsLong(key)</code>&nbsp;‚Ä¶</td>
                <td><code>getAsXxx</code> performs <strong>cross-type conversion</strong>, including semantic conversions (e.g. <code>String</code> ‚Üí <code>Number</code>, <code>Boolean</code> ‚Üí <code>String</code>).</td>
              </tr>
              <tr>
                <td></td>
                <td><code>put(key, value)</code><br><code>remove(key)</code>&nbsp;‚Ä¶</td>
                <td>Mutation operations: insert, replace, and remove.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>toBuilder().put(..).put()</code></td>
                <td>Builder-style API supporting fluent, chained operations.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Examples</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">String json = "{\n" +
        "  \"id\": 1,\n" +
        "  \"name\": \"Alice\",\n" +
        "  \"active\": true,\n" +
        "  \"tags\": [\"java\", \"json\"],\n" +
        "  \"scores\": [95, 88.8, 0.5],\n" +
        "  \"user\": {\n" +
        "    \"role\": \"coder\",\n" +
        "    \"profile\": {\n" +
        "      \"level\": 7,\n" +
        "      \"values\": [1, \"two\", true, null, { \"x\": 3 }]\n" +
        "    }\n" +
        "  }\n" +
        "}";

JsonObject jo = JsonObject.fromJson(json);
// Parse JSON string to JsonObject

Object node = jo.getNode("id");
// Retrieve the raw node as an Object without type conversion.
// Return null if the key is missing.

Integer id = jo.getInteger("id");
// Retrieve the node as a specific type using getXxx(key).
// Performs numeric conversion within the Number hierarchy if necessary.

double id2 = jo.getDouble("id", 0d);
// Returns the node value, or the default if the property is null or missing.

String name = jo.get("name", String.class);
// Retrieve the node with an explicit type parameter.

String name1 = jo.get("name");
// Dynamic type inference ‚Äî type is inferred from context.

String active = jo.getAsString("active");
// Retrieve and convert the node value across types (Boolean ‚Üí String).

String active2 = jo.getAs("active");
// Dynamic type conversion, short form of getAs(key, type).

String role = jo.getJsonObject("user").get("role");
// Chain operations for nested nodes.

jo.put("extra", "blabla");
// See also: putNonNull(), putIfAbsent(), computeIfAbsent()

jo.toBuilder().putIfAbsent("x", "xx").put("y", "yy");
// Builder-style chained operations.

jo.remove("extra");
// See also: removeIf(), forEach() etc.</code></pre>
        </div>

        <div class="callout">
          <strong>Note:</strong> <code>JsonArray</code> represents JSON Array nodes.
          It follows the same API philosophy as <code>JsonObject</code> ‚Äî JSON-semantic access,
          mutation, and type conversion ‚Äî but applies them to ordered array elements rather than object properties.
        </div>
      </section>

      <!-- ======== JSONPATH ======== -->
      <section id="jsonpath" class="section">
        <h2><span class="section-icon">üî≠</span> JsonPath</h2>
        <p>
          <code>JsonPath</code> fully supports the
          <a href="https://datatracker.ietf.org/doc/html/rfc9535" target="_blank" rel="noopener">JSON Path (RFC 9535)</a>
          and
          <a href="https://datatracker.ietf.org/doc/html/rfc6901" target="_blank" rel="noopener">JSON Pointer (RFC 6901)</a>
          specifications.
        </p>

        <h3>Path-Based Methods</h3>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Class</th><th>Methods</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td>JsonPath</td>
                <td><code>JsonPath.compile(path)</code></td>
                <td>Compiles a JSON Path or JSON Pointer expression into a <strong>reusable</strong> <code>JsonPath</code> instance.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>getXxx()</code> ‚Ä¶<br><code>getAsXxx()</code> ‚Ä¶</td>
                <td>Returns a <strong>single matched node</strong>. Returns <code>null</code> if no nodes found.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>find(node)</code><br><code>findAs(node, type)</code></td>
                <td>Returns a <strong>list of matched nodes</strong>. Returns an <strong>empty list</strong> if no nodes matched.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>eval(node)</code><br><code>evalAs(node, type)</code></td>
                <td>Returns a flexible result: a single node, a list, a function result, or <code>null</code>.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>add(node, value)</code><br><code>replace(node, value)</code><br><code>remove(node)</code></td>
                <td>Applies mutation operations at the path location, following JSON Patch‚Äìstyle semantics.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>ensurePut(node, value)</code></td>
                <td>Ensures the path exists and inserts the value, <strong>creating intermediate nodes if necessary</strong>.</td>
              </tr>
              <tr>
                <td>JsonObject<br>JsonArray</td>
                <td><code>getByPath(path)</code> ‚Ä¶<br><code>findByPath(path)</code> ‚Ä¶<br><code>evalByPath(path)</code> ‚Ä¶</td>
                <td>One-shot path evaluation APIs that compile and execute the path against the current container.</td>
              </tr>
              <tr>
                <td></td>
                <td><code>addByPath(path, value)</code><br><code>removeByPath(path)</code> ‚Ä¶</td>
                <td>One-shot path-based mutation APIs applied directly to the current container.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Examples</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">JsonPath path = JsonPath.compile("$.user.role");
Object role2 = path.getNode(jo);
// Compiles the JSONPath expression into a reusable JsonPath instance.

String role3 = jo.getStringByPath("/user/role");
// Uses a JSON Pointer expression via a one-shot path API.

String role4 = jo.getAsByPath("$..role");
// Uses the descendant operator (..) for deep traversal.

List&lt;String&gt; tags = jo.findByPath("$.tags[*]", String.class);
// Wildcard (*) matches all array elements; find() always returns a list.

List&lt;Short&gt; scores = jo.findAsByPath("$.scores[0:3]", Short.class);
// Array slicing ([start:end:step]).

List&lt;Object&gt; unions = jo.findByPath("$.user['role','profile']");
// Union expression to select multiple object members.

int count = JsonPath.compile("$.scores.count()").eval(jo, int.class);
// Calls the count() function at the end of the path.

jo.addByPath("$.aa", "bb");
// Adds a new property at the specified path.

jo.ensurePutNonNullByPath("$.cc.dd[0]", 100);
// Ensures the full path exists; creates intermediate objects/arrays.
// Result: {..., "cc": {"dd": [100]}}

JsonPointer.compile("/scores/2").remove(jo);
// Removes an array element using JsonPointer.</code></pre>
        </div>

        <h3>JSON Path Syntax</h3>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Syntax</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
              <tr><td><code>$</code></td><td>Root object</td><td><code>$.name</code></td></tr>
              <tr><td><code>@</code></td><td>Current node (only in filter context)</td><td><code>@.name</code></td></tr>
              <tr><td><code>.name</code>, <code>['name']</code></td><td>Object member name</td><td><code>$['store'].book</code></td></tr>
              <tr><td><code>[index]</code></td><td>Array index (0-based; negative from end)</td><td><code>$.store['book'][0]</code></td></tr>
              <tr><td><code>.*</code>, <code>[*]</code></td><td>Wildcard (all children)</td><td><code>$.store[*]</code></td></tr>
              <tr><td><code>..</code></td><td>Recursive descent</td><td><code>$..author</code></td></tr>
              <tr><td><code>[start:end]</code>, <code>[start:end:step]</code></td><td>Array slice (end exclusive)</td><td><code>$.*.book[1:3]</code></td></tr>
              <tr><td><code>[index1, index2]</code>, <code>['name1', 'name2']</code></td><td>Union of indices or members</td><td><code>$.store.book[0, -1]</code></td></tr>
              <tr><td><code>[?(&lt;filter&gt;)]</code></td><td>Filter expression</td><td><code>$..book[?@.price &lt; 10]</code></td></tr>
              <tr><td><code>func()</code></td><td>Function call</td><td><code>$..book.size()</code></td></tr>
            </tbody>
          </table>
        </div>

        <h3>Filter Expressions</h3>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Syntax</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
              <tr><td><code>@</code>, <code>$</code></td><td>Path expression (automatically evaluated)</td><td><code>$.orders[?(@.amount &gt; $.config.minAmount)]</code></td></tr>
              <tr><td><code>==</code>, <code>!=</code></td><td>Equality / inequality</td><td><code>@.category == 'fiction'</code></td></tr>
              <tr><td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td><td>Numeric comparison</td><td><code>@.price &gt;= 20</code></td></tr>
              <tr><td><code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>()</code></td><td>Logical operators and grouping</td><td><code>@.author != null || !@.isbn</code></td></tr>
              <tr><td><code>=~</code></td><td>Full regular expression match</td><td><code>@.author =~ /.*lice/i</code></td></tr>
            </tbody>
          </table>
        </div>

        <h3>Filter Functions</h3>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Function</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
              <tr><td><code>length()</code></td><td>Length of a string, array, or object</td><td><code>$[?length(@.authors) &gt;= 5]</code></td></tr>
              <tr><td><code>count()</code></td><td>Number of nodes in a nodelist</td><td><code>$[?count(@.*.author) &gt;= 5]</code></td></tr>
              <tr><td><code>match()</code></td><td>Tests whether a string matches an I-Regexp (RFC 9485)</td><td><code>$[?match(@.date, "1974-05-..")]</code></td></tr>
              <tr><td><code>search()</code></td><td>Tests whether a string contains a substring that <code>match()</code>es</td><td><code>$[?search(@.author, "[BR]ob")]</code></td></tr>
              <tr><td><code>value()</code></td><td>Convert a NodesType instance to a value</td><td><code>$[?value(@..color) == "red"]</code></td></tr>
              <tr><td><code>sum()</code>, <code>min()</code>, <code>max()</code>, <code>avg()</code>, <code>stddev()</code></td><td>Numeric aggregation functions</td><td><code>$[?sum(@.price) &lt; 20]</code></td></tr>
              <tr><td><code>first()</code>, <code>last()</code>, <code>index()</code></td><td>First, last, or indexed element</td><td><code>$[?first(@.title) =~ /^J/]</code></td></tr>
            </tbody>
          </table>
        </div>

        <h3>Extensibility</h3>
        <p>JSON Path can be extended with custom functions via <code>FunctionRegistry.register()</code>:</p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">FunctionRegistry.register(new FunctionRegistry.FunctionDescriptor("hi", args -> {
    return "hi, " + Arrays.toString(args);
}));
String hi = JsonObject.fromJson("{\"aa\":\"bb\"}").evalByPath("$.hi()", String.class);
assertEquals("hi, [J{aa=bb}]", hi);</code></pre>
        </div>

        <h3>JSON Pointer Syntax</h3>
        <p>JSON Pointer paths always start with <code>/</code> and only support direct navigation (no wildcards or filters).</p>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Syntax</th><th>Description</th><th>Example</th></tr>
            </thead>
            <tbody>
              <tr><td><code>/</code></td><td>Root separator</td><td><code>/</code> (root)</td></tr>
              <tr><td><code>/name</code></td><td>Object member access</td><td><code>/store/book</code></td></tr>
              <tr><td><code>/0</code></td><td>Array index (0-based)</td><td><code>/store/book/0</code></td></tr>
              <tr><td><code>~0</code></td><td>Escape for <code>~</code> character</td><td><code>/a~0b</code></td></tr>
              <tr><td><code>~1</code></td><td>Escape for <code>/</code> character</td><td><code>/a~1b</code></td></tr>
            </tbody>
          </table>
        </div>
        <div class="callout">
          <strong>Note:</strong> <code>JsonPointer</code> is a specialized subclass of <code>JsonPath</code>.
          It behaves identically, except that it only accepts JSON Pointer expressions.
        </div>
      </section>

      <!-- ======== NODESTREAM ======== -->
      <section id="nodestream" class="section">
        <h2><span class="section-icon">üåä</span> NodeStream</h2>
        <p>
          Beyond path-based access with <code>JsonPath</code>, SJF4J provides a programmatic,
          declarative traversal and stream-based processing model via <code>NodeStream</code>.
        </p>

        <h3>Stream-Based Selection and Filtering</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">List&lt;String&gt; tags = jo.stream()
        .findByPath("$.tags[*]", String.class)      // Path-based selection
        .filter(tag -> tag.length() > 3)            // Programmatic filtering
        .toList();</code></pre>
        </div>

        <h3>Multi-Stage Evaluation</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">int x = jo.stream()
        .findAsByPath("$..profile", JsonObject.class)   // Primary findAsByPath()
        .filter(n -> n.hasNonNull("values"))
        .getAsByPath("$..x", Integer.class)             // Secondary asByPath()
        .findFirst()
        .orElse(4);</code></pre>
        </div>

        <h3>Aggregation and Computation</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">double avgScore = jo.stream()
        .find("$.scores[*]", Double.class)
        .map(d -> d &lt; 60 ? 60 : d)                      // Custom normalization
        .collect(Collectors.averagingDouble(s -> s));</code></pre>
        </div>

        <h3>Depth-First Traversal with <code>walk()</code></h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">jo.walk(
        Target.CONTAINER,       // Target: CONTAINER or VALUE
        Order.BOTTOM_UP,        // Order:  BOTTOM_UP (leaf-to-root) or TOP_DOWN (root-to-leaf)
        (path, node) -> {
            System.out.println("path=" + path + ", node=" + node);
            return Control.CONTINUE;
            // CONTINUE to proceed, or STOP to terminate traversal
        });</code></pre>
        </div>
      </section>

      <!-- ======== JOJO ======== -->
      <section id="jojo" class="section">
        <h2><span class="section-icon">üèóÔ∏è</span> JOJO ‚Äî Domain Modeling</h2>
        <p>
          In real applications, data is rarely purely dynamic JSON or strictly static Java objects.
          SJF4J bridges this with <strong>JOJO</strong> and <strong>JAJO</strong> ‚Äî hybrid models
          between <code>POJO</code> and <code>Map</code>/<code>List</code>, combining
          <strong>typed Java fields and methods</strong> with <strong>JSON-semantic dynamic access</strong> in the OBNT.
        </p>

        <h3>JOJO vs POJO</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">// Define a POJO User
static class User {
    String name;
    List&lt;User&gt; friends;
    // Getter and setter
}

// Define a JOJO User2
static class User2 extends JsonObject {
    String name;
    List&lt;User2&gt; friends;
    // Getter and setter
}

String json = "{\"name\":\"Alice\",\"friends\":[{\"name\":\"Bill\",\"active\":true}],\"age\":18}";

User  user  = Sjf4j.fromJson(json, User.class);
User2 user2 = Sjf4j.fromJson(json, User2.class);

assertEquals(user.getName(), user2.getName());
assertEquals(user.getName(), user2.getString("name"));
// For declared fields, POJO and JOJO behave exactly the same.

assertEquals(18, user2.getInteger("age"));
// JOJO can still retain and access undeclared properties.

List&lt;String&gt; allFriends = user2.findByPath("$.friends..name", String.class);
// ["Bill", "Cindy", "David"]
// JOJO provides JSON-semantic APIs on top of the domain model!</code></pre>
        </div>

        <h3>Starting from Scratch</h3>
        <p>At an early stage you may start with an <strong>empty JOJO</strong>:</p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">public class Book extends JsonObject {
    // Empty at the beginning ‚Äî already a fully functional JsonObject
}

// Later, promote core properties to typed fields as the system stabilizes:
public class Book extends JsonObject {
    private String isbn;
    private String title;
    // Getter and setter
}</code></pre>
        </div>

        <h3>Starting from an Existing Codebase</h3>

        <h4>1. Map-based codebases</h4>
        <p>
          Codebases built on Java <code>Map</code>/<code>List</code>, Jackson <code>JsonNode</code>,
          Gson <code>JsonObject</code>, or Fastjson2 <code>JSONObject</code> can migrate to
          SJF4J's <code>JsonObject</code>/<code>JsonArray</code> directly, preserving the existing
          data model while gaining a unified JSON-semantic API.
        </p>

        <h4>2. POJO-based codebases</h4>
        <p>Two options when inheritance is not feasible (Java <code>Record</code>, Protobuf, external classes):</p>

        <p><strong>Option 1: Low-level static APIs</strong></p>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Helper Class</th><th>Static Methods</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>Sjf4j</code></td>
                <td><code>Sjf4j.fromJson()</code> ‚Ä¶<br><code>Sjf4j.toYaml()</code> ‚Ä¶</td>
                <td>Entry-point helpers for parsing, serialization, and cross-format conversion.</td>
              </tr>
              <tr>
                <td><code>Nodes</code></td>
                <td><code>Nodes.toLong()</code> ‚Ä¶<br><code>Nodes.asString()</code> ‚Ä¶<br><code>Nodes.inspect()</code> ‚Ä¶</td>
                <td>Node-level access, conversion, inspection, and comparison utilities.</td>
              </tr>
              <tr>
                <td><code>Nodes</code></td>
                <td><code>Nodes.visitObject()</code><br><code>Nodes.sizeInList()</code><br><code>Nodes.setInObject()</code> ‚Ä¶</td>
                <td>Traversal and mutation of the Object-Based Node Tree.</td>
              </tr>
              <tr>
                <td><code>Patches</code></td>
                <td><code>Patches.diff()</code><br><code>Patches.merge()</code> ‚Ä¶</td>
                <td>JSON Patch‚Äìbased operations.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">// Using JOJO's forEach
user2.forEach((k, v) -> System.out.println("key=" + k + " value=" + v));

// Equivalent for any POJO using low-level static API
Nodes.visitObject(user, (k, v) -> System.out.println("key=" + k + " value=" + v));</code></pre>
        </div>

        <p><strong>Option 2: Projecting POJO to JsonObject</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">JsonObject userJo = JsonObject.fromNode(user);  // Project POJO as JsonObject
// ... process with full JSON-semantic API ...
user = userJo.toPojo(User.class);               // Materialize back to POJO

// Nodes.toXxx() implements shallow copy (or direct references for matching types).
// Sjf4j.readNode() / deepNode() is for deep copy.</code></pre>
        </div>

        <div class="callout">
          <strong>About JAJO (JSON Array Java Object):</strong>
          Unlike JOJO, a JAJO extends <code>JsonArray</code> but intentionally introduces no additional fields.
          Its purpose is <em>modeling rather than structure</em> ‚Äî by assigning a dedicated type to an
          array-based structure, JAJO allows domain-specific behavior to be expressed through methods.
          For example, <code>JsonPatch</code> is fundamentally a JSON array, but modeled as a JAJO,
          it exposes domain operations like <code>diff()</code> and <code>apply()</code>.
        </div>
      </section>

      <!-- ======== SJF4J API ======== -->
      <section id="sjf4j-api" class="section">
        <h2><span class="section-icon">üîÑ</span> Data Conversion (Sjf4j)</h2>
        <p>
          <code>Sjf4j</code> provides a unified set of entry-point APIs for converting between
          JSON-like data formats and the Object-Based Node Tree.
        </p>

        <h3>Examples</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">JsonObject jo           = Sjf4j.fromJson(json);     // = JsonObject.fromJson(json)
Map&lt;String, Object&gt; map = Sjf4j.fromYaml(yaml, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {});
User user               = Sjf4j.fromProperties(properties, User.class);
User2 user2             = Sjf4j.fromNode(user, User2.class);
// Uses reference-based mapping whenever feasible; otherwise performs a shallow copy.

String json1      = Sjf4j.toJson(map);
String yaml1      = Sjf4j.toYaml(jo);        // = jo.toYaml()
Properties props1 = Sjf4j.toProperties(user);
// {"aa":{"bb":[{"cc":"dd"}]}} => aa.bb[0].cc=dd

User user1 = Sjf4j.fromNode(user2, User.class);
// Conversion is symmetric ‚Äî fromNode() handles both directions.

User user3 = Sjf4j.deepNode(user2);
// Always performs a deep copy; the resulting graph is fully detached from the source.</code></pre>
        </div>

        <h3>Extensibility: <code>@NodeValue</code> Annotation</h3>
        <p>
          SJF4J allows custom Java types to participate in the OBNT via the
          <code>@NodeValue</code> annotation or the <code>ValueCodec</code> interface.
        </p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">@NodeValue
public static class BigDay {
    private final LocalDate localDate;
    public BigDay(LocalDate localDate) {
        this.localDate = localDate;
    }

    @Encode
    public String encode() {
        return localDate.toString();  // Encodes to a raw String in OBNT
    }

    @Decode
    public static BigDay decode(String raw) {
        return new BigDay(LocalDate.parse(raw));  // Decodes from raw String
    }

    @Copy
    public BigDay copy() {
        return new BigDay(localDate);  // Deep copy
    }
}

// Register and use:
NodeRegistry.registerValueCodec(BigDay.class);

BigDay day = Sjf4j.fromJson("\"2026-01-01\"", BigDay.class);
assertEquals("\"2026-01-01\"", Sjf4j.toJson(day));</code></pre>
        </div>

        <h3>Extensibility: <code>ValueCodec</code> Interface</h3>
        <p>For JDK classes or third-party types where annotations are not possible:</p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">NodeRegistry.registerValueCodec(new ValueCodec&lt;LocalDate, String&gt;() {
    @Override
    public String encode(LocalDate node) {
        return node.toString();
    }

    @Override
    public LocalDate decode(String raw) {
        return LocalDate.parse(raw);
    }

    @Override
    public Class&lt;LocalDate&gt; getValueClass() {
        return LocalDate.class;
    }

    @Override
    public Class&lt;String&gt; getRawClass() {
        return String.class;
    }
});</code></pre>
        </div>
      </section>

      <!-- ======== JSONPATCH ======== -->
      <section id="jsonpatch" class="section">
        <h2><span class="section-icon">üîß</span> JsonPatch</h2>
        <p>
          <code>JsonPatch</code> provides a complete and extensible implementation of
          <a href="https://datatracker.ietf.org/doc/html/rfc6902" target="_blank" rel="noopener">JSON Patch (RFC 6902)</a>,
          enabling declarative, path-based modifications to the Object-Based Node Tree.
        </p>

        <h3>Applying a Patch</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">JsonObject before = JsonObject.fromJson("{\n" +
    "  \"name\": \"Bob\",\n" +
    "  \"scores\": [90, 95, 98],\n" +
    "  \"active\": true\n" +
    "}");

JsonPatch patch1 = JsonPatch.fromJson("[\n" +
    "  { \"op\": \"add\",     \"path\": \"/scores/-\", \"value\": 100 },\n" +
    "  { \"op\": \"replace\", \"path\": \"/name\",     \"value\": \"Alice\" },\n" +
    "  { \"op\": \"remove\",  \"path\": \"/active\" }\n" +
    "]");

before.apply(patch1);

JsonObject after = JsonObject.fromJson("{\"name\":\"Alice\",\"scores\":[90,95,98,100]}");
assertEquals(after, before);</code></pre>
        </div>

        <h3>State Restoration via <code>diff()</code> and <code>apply()</code></h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">List&lt;Integer&gt; source = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));
List&lt;Integer&gt; target = new ArrayList&lt;&gt;(Arrays.asList(1, 5, 3, 4));

JsonPatch patch = JsonPatch.diff(source, target);
patch.apply(source);
assertEquals(target, source);</code></pre>
        </div>

        <h3>Patch Operations</h3>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Operation</th><th>Spec</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr><td><code>add</code></td><td>RFC 6902</td><td>Adds a value at the target path</td></tr>
              <tr><td><code>remove</code></td><td>RFC 6902</td><td>Removes the value at the target path</td></tr>
              <tr><td><code>replace</code></td><td>RFC 6902</td><td>Replaces the value at the target path (must already exist)</td></tr>
              <tr><td><code>move</code></td><td>RFC 6902</td><td>Moves a value from one path to another</td></tr>
              <tr><td><code>copy</code></td><td>RFC 6902</td><td>Copies a value from one path to another</td></tr>
              <tr><td><code>test</code></td><td>RFC 6902</td><td>Tests whether the value at the path equals the expected value</td></tr>
              <tr><td><code>exist</code></td><td>SJF4J</td><td>Asserts that the target path exists</td></tr>
              <tr><td><code>ensurePut</code></td><td>SJF4J</td><td>Ensures the path exists and inserts the value, creating intermediate nodes if necessary</td></tr>
            </tbody>
          </table>
        </div>

        <h3>Extensibility</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">// Extend or override patch operations via PatchOpRegistry
PatchOpRegistry.register("add", (target, op) -> {
    op.getPath().add(target, op.getValue());    // Replace with custom logic
});</code></pre>
        </div>

        <h3>JSON Merge Patch (RFC 7386)</h3>
        <p>SJF4J also supports <a href="https://datatracker.ietf.org/doc/html/rfc7386" target="_blank" rel="noopener">JSON Merge Patch (RFC 7386)</a> for partial updates:</p>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Method</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr>
                <td><code>mergeRfc7386(Object mergePatch)</code></td>
                <td>RFC 7386 semantics: patch values replace target; <code>null</code> fields are removed; nested objects merged recursively; arrays replaced as a whole.</td>
              </tr>
              <tr>
                <td><code>merge(Object mergePatch, boolean overwrite, boolean deepCopy)</code></td>
                <td>Flexible merge: <code>overwrite</code> controls whether existing values are replaced; <code>deepCopy</code> controls deep vs. reference copy; <code>null</code> patch values are no-ops; arrays merged recursively.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- ======== JSONSCHEMA ======== -->
      <section id="jsonschema" class="section">
        <h2><span class="section-icon">‚úÖ</span> JsonSchema</h2>
        <p>
          SJF4J offers
          <a href="https://bowtie.report/#/implementations/java-sjf4j" target="_blank" rel="noopener">full compliance</a>
          with <a href="https://json-schema.org/" target="_blank" rel="noopener">JSON Schema Draft 2020-12</a>
          and goes beyond raw JSON validation. It performs native, high-performance validation for
          POJOs, JOJOs, Maps, Lists, and any Java object model ‚Äî without intermediate conversions.
        </p>

        <h3>Basic Validation</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">JsonSchema schema = JsonSchema.fromJson("{ \"type\": \"number\" }");
schema.compile();
// Prepares the schema for validation

assertTrue(schema.isValid(1));

ValidationResult result = schema.validate("a");
assertFalse(result.isValid());
assertEquals("type", result.getLastMessage().getKeyword());</code></pre>
        </div>

        <h3>Object Validation with <code>properties</code></h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">JsonSchema schema = JsonSchema.fromJson("{\n" +
        "  \"type\": \"object\",\n" +
        "  \"properties\": {\n" +
        "    \"name\": {\"type\": \"string\", \"minLength\": 5}\n" +
        "  }\n" +
        "}");

Map&lt;String, Object&gt; map = Map.of("name", "Alice");
assertTrue(schema.isValid(map));        // Map validated directly

MyPojo pojo = new MyPojo();
pojo.setName("Tom");
assertFalse(schema.isValid(pojo));      // POJO validated directly</code></pre>
        </div>

        <h3>Validating POJOs with <code>@ValidJsonSchema</code></h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">@ValidJsonSchema("""
{
    "type": "object",
    "required": ["id"],
    "properties": {
        "id": { "type": "integer" },
        "user": { "format": "email" }
    }
}
""")
public class Order {
    public int id;
    public String user;
}</code></pre>
        </div>

        <h3>Binding via <code>ref</code></h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">@ValidJsonSchema(ref = "domain.schema.json#User")           // $anchor
public class UserDto { ... }

@ValidJsonSchema(ref = "domain.schema.json#/$defs/User")    // JSON Pointer
public class UserDto2 { ... }

@ValidJsonSchema                    // Convention-based: UserDto3.schema.json
public class UserDto3 { ... }</code></pre>
        </div>

        <h3>Schema Location Rules</h3>
        <ul>
          <li>Default base directory: <code>classpath:///json-schemas/</code></li>
          <li>If no <code>value</code> or <code>ref</code> is provided, SJF4J tries <code>&lt;fully.qualified.ClassName&gt;.schema.json</code> then <code>&lt;SimpleName&gt;.schema.json</code></li>
          <li>Supported <code>ref</code> schemes: <code>classpath:///</code>, <code>file:///</code></li>
          <li>Network schemes (e.g. <code>https://</code>) are not loaded, unless used purely as <code>$id</code> identifiers</li>
        </ul>

        <h3>SchemaValidator Usage</h3>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-java">SchemaValidator validator = new SchemaValidator();
ValidationResult result = validator.validate(new UserDto());</code></pre>
        </div>
      </section>

      <!-- ======== BENCHMARK ======== -->
      <section id="benchmark" class="section">
        <h2><span class="section-icon">‚ö°</span> Benchmark</h2>
        <p>
          All benchmarks are reproducible and implemented using
          <strong>JMH (Java Microbenchmark Harness)</strong>.
        </p>

        <h3>Read / Write Benchmark</h3>
        <p>
          Source:
          <a href="https://github.com/sjf4j-projects/sjf4j/blob/main/sjf4j/src/jmh/java/org/sjf4j/ReadBenchmark.java" target="_blank" rel="noopener">ReadBenchmark.java</a>.
          Sample JSON (~1 KB) with nested objects and arrays.
        </p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-text">Benchmark                                    Mode  Cnt  Score   Error  Units
ReadBenchmark.json_jackson_facade            avgt    5  0.750 ¬± 0.023  us/op
ReadBenchmark.json_jackson_native_has_any    avgt    5  0.717 ¬± 0.028  us/op
ReadBenchmark.json_jackson_native_map        avgt    5  0.633 ¬± 0.062  us/op
ReadBenchmark.json_jackson_native_no_any     avgt    5  0.458 ¬± 0.014  us/op
ReadBenchmark.json_gson_facade               avgt    5  1.130 ¬± 0.225  us/op
ReadBenchmark.json_gson_native_map           avgt    5  1.010 ¬± 0.054  us/op
ReadBenchmark.json_gson_native_no_any        avgt    5  0.893 ¬± 0.087  us/op
ReadBenchmark.json_fastjson2_facade          avgt    5  0.579 ¬± 0.082  us/op
ReadBenchmark.json_fastjson2_native_has_any  avgt    5  0.490 ¬± 0.050  us/op
ReadBenchmark.json_fastjson2_native_map      avgt    5  0.383 ¬± 0.008  us/op
ReadBenchmark.json_fastjson2_native_no_any   avgt    5  0.220 ¬± 0.011  us/op
ReadBenchmark.json_simple_facade             avgt    5  2.756 ¬± 0.116  us/op</code></pre>
        </div>

        <div class="callout">
          <strong>Performance Summary:</strong> Using SJF4J adds roughly <strong>5%‚Äì10% overhead</strong>
          compared with native JSON libraries, while providing a unified API and extended functionality.
        </div>

        <h3>Reflection Benchmark</h3>
        <p>
          SJF4J's OBNT relies on reflection for flexible access to POJO/JOJO/JAJO.
          Source:
          <a href="https://github.com/sjf4j-projects/sjf4j/blob/main/sjf4j/src/jmh/java/org/sjf4j/ReflectionBenchmark.java" target="_blank" rel="noopener">ReflectionBenchmark.java</a>.
        </p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-text">Benchmark                                            Mode  Cnt  Score    Error  Units
ReflectionBenchmark.reflection_ctor_lambda           avgt    5  0.007 ¬±  0.001  us/op
ReflectionBenchmark.reflection_ctor_methodHandler    avgt    5  0.008 ¬±  0.001  us/op
ReflectionBenchmark.reflection_ctor_native           avgt    5  0.007 ¬±  0.001  us/op
ReflectionBenchmark.reflection_getter_lambda         avgt    5  0.005 ¬±  0.001  us/op
ReflectionBenchmark.reflection_getter_methodHandler  avgt    5  0.008 ¬±  0.001  us/op
ReflectionBenchmark.reflection_getter_native         avgt    5  0.005 ¬±  0.001  us/op
ReflectionBenchmark.reflection_setter_lambda         avgt    5  0.007 ¬±  0.001  us/op
ReflectionBenchmark.reflection_setter_methodHandler  avgt    5  0.009 ¬±  0.001  us/op
ReflectionBenchmark.reflection_setter_native         avgt    5  0.007 ¬±  0.001  us/op</code></pre>
        </div>

        <div class="callout">
          <strong>Performance Summary:</strong> Reflection in SJF4J, when using <strong>lambda-based</strong>
          access, is highly efficient, enabling dynamic object manipulation with
          <strong>near-native performance</strong>.
        </div>
      </section>

      <!-- ======== CONTRIBUTING ======== -->
      <section id="contributing" class="section">
        <h2><span class="section-icon">ü§ù</span> Contributing</h2>
        <p>
          SJF4J is built to <em>make JSON-Oriented Java Development Possible</em> üôÇ<br>
          Feel free to
          <a href="https://github.com/sjf4j-projects/sjf4j/issues/new" target="_blank" rel="noopener">open an issue</a>
          for questions, bugs, ideas, or simply to say hi ‚Äî your interest already means a lot to this project.
        </p>
        <p>
          Contributions of all kinds ‚Äî code, documentation, examples, benchmarking, or simply filing an issue
          ‚Äî are truly appreciated! ‚ù§Ô∏è
        </p>
        <p>Licensed under the <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener">MIT License</a>.</p>

        <div class="cta-buttons" style="margin-top:1.5rem">
          <a href="https://github.com/sjf4j-projects/sjf4j/issues/new" target="_blank" rel="noopener" class="btn btn-primary">Open an Issue</a>
          <a href="https://github.com/sjf4j-projects/sjf4j" target="_blank" rel="noopener" class="btn btn-secondary">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
            GitHub
          </a>
        </div>
      </section>

    </div><!-- /.content -->

    <!-- ============ FOOTER ============ -->
    <footer class="footer">
      <div class="footer-inner">
        <span>SJF4J ‚Äî Simple JSON Facade for Java &nbsp;¬∑&nbsp; ¬© 2025 sjf4j-projects</span>
        <div class="footer-links">
          <a href="https://github.com/sjf4j-projects/sjf4j" target="_blank" rel="noopener">GitHub</a>
          <a href="https://central.sonatype.com/artifact/org.sjf4j/sjf4j" target="_blank" rel="noopener">Maven Central</a>
          <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener">MIT License</a>
        </div>
      </div>
    </footer>

  </main><!-- /.main -->
</div><!-- /.layout -->

<!-- ===================== SCRIPTS ===================== -->
<!-- Mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark',
    themeVariables: {
      background: '#1c2128',
      primaryColor: '#1f3a5f',
      primaryTextColor: '#e6edf3',
      primaryBorderColor: '#30363d',
      lineColor: '#58a6ff',
      secondaryColor: '#161b22',
      tertiaryColor: '#0d1117'
    }
  });
</script>

<!-- Prism.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-groovy.min.js"></script>

<!-- Site JS -->
<script src="js/main.js"></script>

</body>
</html>
